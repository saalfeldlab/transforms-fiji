package org.janelia.saalfeldlab.transform.ants;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

import net.imglib2.realtransform.AffineTransform3D;

/**
 * Loads an affine transform generated by ANTS as an AffineTransform3d.
 * 
 * @author John Bogovic &lt;bogovicj@janelia.hhmi.org&gt;
 *
 */
public class ANTSLoadAffine
{
	public static String toITK( AffineTransform3D xfm )
	{
		StringBuffer out = new StringBuffer();
		out.append("#Insight Transform File V1.0\n");
		out.append("#Transform 0\n");
		out.append("Transform: MatrixOffsetTransformBase_double_3_3\n");

		out.append( String.format( "Parameters: %f %f %f %f %f %f %f %f %f %f %f %f\n", 
				xfm.get( 0, 0 ), xfm.get( 0, 1 ), xfm.get( 0, 2 ),
				xfm.get( 1, 0 ), xfm.get( 1, 1 ), xfm.get( 1, 2 ),
				xfm.get( 2, 0 ), xfm.get( 2, 1 ), xfm.get( 0, 2 ),
				xfm.get( 0, 3 ), xfm.get( 1, 3 ), xfm.get( 2, 3 ) ));

		// the mtx takes care of the centering / un-centering, so we can set center to zero
		out.append( "FixedParameters: 0.0 0.0 0.0" );

		return out.toString();
	}

	/**
	 * Returns a representation of the given {@link AffineTransform3D},
	 * where the 4D homogeneous matrix is written as a string
	 * 
	 * @param xfm the affine
	 * @returns the 4d homogeneous matrix as a string
	 */
	public static String toHomogeneousMatrixString( AffineTransform3D xfm )
	{
		StringBuffer out = new StringBuffer();
		out.append( String.format( "%f %f %f %f\n%f %f %f %f\n%f %f %f %f\n0 0 0 1", 
				xfm.get( 0, 0 ), xfm.get( 0, 1 ), xfm.get( 0, 2 ), xfm.get( 0, 3 ),
				xfm.get( 1, 0 ), xfm.get( 1, 1 ), xfm.get( 1, 2 ), xfm.get( 1, 3 ),
				xfm.get( 2, 0 ), xfm.get( 2, 1 ), xfm.get( 2, 2 ), xfm.get( 2, 3)));

		return out.toString();
	}

	public static AffineTransform3D loadAffine( String filePath ) throws IOException
	{

		if ( filePath.endsWith( "mat" ) )
			return loadAffineMat( filePath );
		else if ( filePath.endsWith( "txt" ) )
			return loadAffineTxt( filePath );
		else
			return null;
	}

	public static AffineTransform3D loadAffineTxt( String filePath ) throws IOException
	{
		BufferedReader reader = new BufferedReader(
				new FileReader( new File( filePath ) ) );
		String line = null;

		double[] matrix = null;
		double[] center = null;
		while ( (line = reader.readLine()) != null )
		{
			if ( line.startsWith( "Parameters:" ) )
			{
				matrix = parametersNamed( line );

			} else if ( line.startsWith( "FixedParameters:" ) )
			{
				center = parametersNamed( line );
			}
		}
		reader.close();

		return loadAffineParams( matrix, center );
	}
	
	public static AffineTransform3D loadAffineParams( final double[] matrixItk, final double[] center )
	{
		AffineTransform3D affine = fromItkParameters( matrixItk );

		AffineTransform3D invCentering = new AffineTransform3D();
		invCentering.set( center[ 0 ], 0, 3 );
		invCentering.set( center[ 1 ], 1, 3 );
		invCentering.set( center[ 2 ], 2, 3 );

		AffineTransform3D centering = new AffineTransform3D();
		centering.set( -center[ 0 ], 0, 3 );
		centering.set( -center[ 1 ], 1, 3 );
		centering.set( -center[ 2 ], 2, 3 );

		affine = affine.concatenate( centering );
		affine = affine.preConcatenate( invCentering );

		return affine;
	}

	/**
	 * This is necessary since itk's convention differs from imglib2's
	 * @return
	 */
	public static AffineTransform3D fromItkParameters( double[] parameters )
	{
		AffineTransform3D affine = new AffineTransform3D();
		affine.set( 
				parameters[0], parameters[1], parameters[2], parameters[9], 
				parameters[3], parameters[4], parameters[5], parameters[10], 
				parameters[6], parameters[7], parameters[8], parameters[11] );

		return affine;
	}

	// ConvertTransformFile 3 --hm <sourcefile> <destfile.mat>
	public static AffineTransform3D loadAffineMat( String filePath ) throws IOException
	{
		if ( !filePath.endsWith( "mat" ) )
		{
			System.err.println( "Must be a homogenous matrix, try running:" );
			System.err.println( "ConvertTransformFile 3 " + filePath + " " + filePath
					+ ".mat --hm" );
		}

		BufferedReader reader = new BufferedReader( new FileReader( new File( filePath ) ) );
		String line = null;

		double[] mtxDat = new double[ 12 ];

		int i = 0;
		int r = 0;
		while ( (line = reader.readLine()) != null )
		{
			if ( r == 3 )
				break;

			double[] row = parameters( line );

			for ( int c = 0; c < row.length; c++ )
				mtxDat[ i++ ] = row[ c ];

			r++;
		}
		reader.close();


		AffineTransform3D affine = new AffineTransform3D();
		affine.set( mtxDat );

		return affine;
	}

	private static double[] parameters( String paramLine )
	{
		String[] splitLine = paramLine.split( " " );
		double[] out = new double[ splitLine.length ];

		for ( int i = 0; i < splitLine.length; i++ )
			out[ i ] = Double.parseDouble( splitLine[ i ] );

		return out;
	}

	/*
	 * Skips the first element in the line because its a name
	 */
	private static double[] parametersNamed( String paramLine )
	{
		String[] splitLine = paramLine.split( " " );
		// System.out.println( splitLine[ 0 ]);

		double[] out = new double[ splitLine.length - 1 ];

		for ( int i = 1; i < splitLine.length; i++ )
			out[ i - 1 ] = Double.parseDouble( splitLine[ i ] );

		return out;
	}

}
